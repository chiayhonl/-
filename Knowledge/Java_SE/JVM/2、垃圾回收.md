#### 垃圾回收机制

- **GC回收机制?**

	一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制(太拗口，换句话说就是回收无用对象并释放它所占用的内存空间的机制)

- **判断一个对象是否死亡？**

	1. 引用计数器算法：
    
    		创建对象时添加一个引用计数器，每当有一个地方引用它时，引用计数器加一，当引用失效或者超过生命周期时，计数器值减一；
    		任何时刻对象的引用计数器为0的对象就是不可能再被使用的；
    		
    2. 可达性算法分析：
    
    		通过GC Roots进行可达性搜索，一个对象不在任何一条能到达GC Roots的引用链上，则视为不可达对象。
    		则证明此对象是不可用的，JVM稍后将会对此类对象进行回收

- **GCRoots的对象?**

	1. 虚拟机栈中中引用的对象；
    
    2. 本地方法栈中引用的对象
    
    3. 方法区静态属性引用的对象
    
    4. 方法区中常量引用的对象；

- **四引用?**

	1. 强引用（Strong Reference）

    		 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。
    		 
    2. 软引用（Soft Reference）
    
    		 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。
    		 
    3. 弱引用（Weak Reference）
    
         	 弱引用指向的对象发生GC时必定回收它的内存空间。
          
    4.  虚引用（Phantom Reference）
    
    		虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。

- **常见的垃圾收集算法？**

	1. 标记-清除算法：
	
			分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
	
		缺点：
		
			一是效率问题，标记和清除效率都不高，
			二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序在运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
			
	2. 复制算法
	
			可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活这的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
			
		优缺点：
			
			内存分配时不用考虑内存碎片等复杂情况，实现简单运行高效。
			
			但是代价是将内存缩小为了原来的一半。需要使用额外的空间进行分配担保防止全部存活的情况
			且对象存活率较高时就要进行较多的复制操作，效率将会变低
			
	3. 标记-整理算法
	
			标记过程仍与“标记-清除”算法一样，但是后续步骤是让所有的存活对象都向一端移动，然后直接清理掉端边界以外的内存
			
	4. 分代收集算法
	
			根据对象存活周期的不同。一般将内存划分为新生代和老年代，在新生代中采用复制算法,老年代使用“标记-清理”或者“标记-整理”算法。
			

- **MinorGC&FullGC?**

- **内存分配与回收策略?**

- **GC垃圾收集器种类？?**

- **G1相关？与CMS的区别？**

