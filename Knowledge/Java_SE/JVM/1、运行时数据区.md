#### 运行时数据区

- **虚拟机组成部分？用途？**
	
	JVM 整体组成可分为以下四个部分：
	
		类加载器子系统（ClassLoader）
		
		运行时数据区（Runtime Data Area）
		
		执行引擎（Execution Engine）
		
		本地库接口（Native Interface）
		
	![图片加载失败](/Knowledge/其他文件/jvm1.png)
	
	用途：
	
		程序在执行之前先要把java代码转换成字节码（class文件），jvm首先需要把字节码通过类加载器（ClassLoader） 把文件加载到内存中，这
		个内存就是运行时数据区（Runtime Data Area） ，而字节码文件是jvm的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特
		定的命令解析器——执行引擎（Execution Engine） 将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口 
		本地库接口（Native Interface）来实现整个程序的功能，这就是这4个主要组成部分的职责与功能。
        
        
- **虚拟机组成部分(运行时数据区)？**

	分类：
		
		程序计数器（Program Counter Register）
        
		虚拟机栈（Java Virtual Machine Stacks）
		
		本地方法栈（Native Method Stack）
		
		Java堆（Java Heap）
		
		方法区（Method Area）
		
	![图片加载失败](/Knowledge/其他文件/jvm_运行时数据区.png)
	
	作用：
		
	- 程序计数器：	
		
        	1. 可看做当前线程执行的字节码的行号指示器，多线程执行时线程轮流切换时恢复到正确执行位置
        	
        	2. 线程私有
        	
        	3. 线程执行Java方法，记录虚拟机字节码指令地址，执行Native方法，计数器为空
        	
        	4. 唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError区域
        
    - 虚拟机栈：
    
    		1. 线程私有，生命周期与线程相同
    		
        	2. 虚拟机栈描述Java方法执行的内存模型，每个方法执行都会创建一个栈帧，方法的调用和执行完成与该方法栈帧的入栈和出栈对应
        	
        	3. 栈帧是方法运行时的基础数据结构，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
        	
        	4. 此区域包含两种异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；如果虚拟机可以动态扩展，如果扩
        	展时无法申请到足够的内存，就会抛出OutOfMemoryError
        
    - 本地方法栈:
    
			1. 与虚拟机栈所发挥作用相似，区别在于一个为虚拟机执行Java方法服务，一个为虚拟机使用到的Native方法服务
						
			2. 与虚拟机栈一样，抛出StackOverflowError和OutOfMemoryError异常
            
    - 堆：
    	
    		1. Java虚拟机管理的内存中最大一块，虚拟机启动时创建。
        	
        	2. 所有线程共享
        	
        	3. 唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存
        	
        	4. Java堆是垃圾收集器的主要区域
        	
        	5. java堆可以处于物理不连续的内存空间中，逻辑上连续即可。实现时，既可以固定大小，也可以时可扩展的。不过当前主流虚拟机都是可扩展的（-Xmx -Xms）
        	
        	6. 如果在堆中没有完成实例分配，并且堆无法再扩展，将会抛出OutOfMemoryError
        
    - 方法区：
     
			1. 所有线程共享
			
			2. 一般把方法区称为永久代（Permanent Generation）
			
			3. 用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
			
			4. 此区域内存回收主要针对常量池的回收和对类型的卸载。但是回收成绩总是很差，但是确实又是有必要的，否则会有内存泄漏隐患
			
			5. 方法区无法满足内存分布需求时，抛出OutOfMemoryError
            
- **StackOverflowError和OutOfMemeryError的区别？**

	见上
	
	如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；
	如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError
	
- **出现OOM的原因？**

	① 分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。
	② 应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。