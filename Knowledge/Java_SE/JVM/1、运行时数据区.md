#### 运行时数据区

- **虚拟机组成部分？用途？**
	
	JVM 整体组成可分为以下四个部分：
	
		类加载器子系统（ClassLoader）
		
		运行时数据区（Runtime Data Area）
		
		执行引擎（Execution Engine）
		
		本地库接口（Native Interface）
		
	![图片加载失败](/Knowledge/其他文件/jvm1.png)
	
	用途：
	
		程序在执行之前先要把java代码转换成字节码（class文件），jvm首先需要把字节码通过类加载器（ClassLoader） 把文件加载到内存中，这
		个内存就是运行时数据区（Runtime Data Area） ，而字节码文件是jvm的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特
		定的命令解析器——执行引擎（Execution Engine） 将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口 
		本地库接口（Native Interface）来实现整个程序的功能，这就是这4个主要组成部分的职责与功能。
        
        
- **虚拟机组成部分(运行时数据区)？**

	分类：
		
		程序计数器（Program Counter Register）
        
		虚拟机栈（Java Virtual Machine Stacks）
		
		本地方法栈（Native Method Stack）
		
		Java堆（Java Heap）
		
		方法区（Method Area）
		
	![图片加载失败](/Knowledge/其他文件/jvm_运行时数据区.png)
	
	作用：
		
	- 程序计数器：	
		
        	1. 可看做当前线程执行的字节码的行号指示器，多线程执行时线程轮流切换时恢复到正确执行位置
        	
        	2. 线程私有
        	
        	3. 线程执行Java方法，记录虚拟机字节码指令地址，执行Native方法，计数器为空
        	
        	4. 唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError区域
        
    - 虚拟机栈：
    
    		1. 线程私有，生命周期与线程相同
    		
        	2. 虚拟机栈描述Java方法执行的内存模型，每个方法执行都会创建一个栈帧，方法的调用和执行完成与该方法栈帧的入栈和出栈对应
        	
        	3. 栈帧是方法运行时的基础数据结构，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
        	
        	4. 此区域包含两种异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；如果虚拟机可以动态扩展，如果扩
        	展时无法申请到足够的内存，就会抛出OutOfMemoryError
        
    - 本地方法栈:
    
    		1. Java虚拟机管理的内存中最大一块
        	
        	2. 所有线程共享
        	
        	3. 虚拟机启动时创建。唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存
        	
        	4. Java堆时垃圾收集器的主要区域
        	
        	5. Java堆可以处于物理不连续的内存空间中，逻辑上连续即可。实现时，既可以固定大小，也可以时可扩展的。不过当前主流虚拟机都是可扩展的（-Xmx -Xms）
        	如果在堆中没有完成实例分配，并且堆无法再扩展，将会抛出OutOfMemoryError
        
    - 堆：
    	
    		1. Java虚拟机管理的内存中最大一块
        	
        	2. 所有线程共享
        	
        	3. 虚拟机启动时创建。唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存
        	
        	4. Java堆时垃圾收集器的主要区域
        	
        	5. java堆可以处于物理不连续的内存空间中，逻辑上连续即可。实现时，既可以固定大小，也可以时可扩展的。不过当前主流虚拟机都是可扩展的（-Xmx -Xms）
        	
        	6. 如果在堆中没有完成实例分配，并且堆无法再扩展，将会抛出OutOfMemoryError
        
    - 方法区：
     
			1. 所有线程共享
			
			2. 用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
			
			3. Java虚拟机规范将其描述为堆的一个逻辑部分，但是它又一个别名叫做Non-Heap
			
			4. 习惯HotSpot开发部署人员更愿意把方法区称为永久代（Permanent Generation），本质上并不等价，只是HotSpot团队选择把GC分代收集扩展至方法区，以使垃圾收集像管理堆一样管理这部分内存，省去编写方法区内存管理工作，其他虚拟机（J9）不存在永久代概念，实现方法区不受虚拟机规范约束
			
			5. 使用永久代因为通过-XX:MaxPermSize（jdk8已经取消）限制的上限，更容易内存溢出。极少数方法（如String.intern()）会因这个导致在不同虚拟机下有不同表现。JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出
			
			6. 此区域内存回收主要针对常量池的回收和对类型的卸载。但是回收成绩总是很差，但是确实又是有必要的，否则会有内存泄漏隐患
			
			7. 方法区无法满足内存分布需求时，抛出OutOfMemoryError
            
- **StackOverflowError和OutOfMemeryError的区别？**

- **出现OOM的原因？**