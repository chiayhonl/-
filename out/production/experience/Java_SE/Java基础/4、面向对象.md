#### 面向对象

- **面向对象的三大特性？**

	**封装**：(数据隐藏)将客观事物的属性和行为抽象成一个类，并对该类实例的调用者隐藏了数据的实现方式。
	
	**继承**	：继承是从已有类得到继承信息创建新类的过程。提供继承的类叫父类（超类、基类）、得到继承的类叫子类（派生类）。
	
	**多态**：多态是同一个行为具有多个不同表现形式或形态的能力，分为编译时多态和运行时多态。在面向对象编程里多态常指的是发生
	在父类引用指向孩子类对象时的多态 。换句话说，不同的对象进行同一操作可以有不同的实现方式。这种多态是子类型多态或着说运行时
	多态。实现多态的三个条件 ①子类继承父类②子类重写父类③父类引用指向子类对象

- **重载和重写的区别？**

	**重载**：编译时多态，一般指在同一个类中同名方法不同参数列表的情况。一个方法是否重载与返回值、抛出异常、访问修饰符无关。

	**重写**：运行时多态，一般指在子类方法的签名与父类相同而实现内容不同的情况。且方法的返回值类型范围不能比父类的返回值类型更大，
	(注意:基本类型没有子类，故返回值为基本类型时必须相等),声明异常范围不能比父类更广，访问修饰符范围不能父类更小(因此当父类方法
	访问修饰符为private时，不可重写，因为private访问权限最小。private方法属于final方法---《thinking in java》)    
	

- **接口和抽象类的区别是什么？为什么有抽象类还要接口？**  

	***区别：***

	相同点：
	
		都不能被实例化。
	
	不同点：
	
		1. 关于设计层面：抽象类是对类的抽象，是一种设计模板（基本共性内容），接口是行为的抽象，是一种行为的规范（功能拓展）

		2. 关于访问控制符：
	          抽象类的属性四种都可以用(默认default)，方法：1.8前可使用protected及以上（默认protected），1.8可使用default
	          及以上(默认default)
	          接口的属性默认是public static final的，方法：1.8前只能是public，1.8时可以是public和default(默认public) 
	          
	    3. 关于多继承：一个类只能通过关键字extends继承一个抽象类，但可以通过关键字implement实现多个接口
	 
	***原因：*** 
		
		首先要明白，接口不是类，是对抽象类更深层次的抽象。之所以有了抽象类还引入接口：
		
		1. 接口弥补java不能多继承的缺点。
		
		2. 抽象类是为了减少代码复用，将共有的方法与属性通过继承关系上移，使得子类不用编写重复代码。而接口则是为了进行功能的扩展，
		规定了实现类必须具有什么方法且必须实现，并对接口的成员变量的修改进行关闭（即对扩展开放，对修改闭合）   
		

- **String 、 StringBuilder 、 StringBuffer区别？**

	相同点：三个都可进行字符串操作。
	
	不同点：
	
		①String是字符串常量。StringBuilder 、 StringBuffer是字符串变量。由String创建的字符串内容是不可变的，而由StringBuilder 
		、 StringBuffer创建的字符串内容是可改变的。
		
		②StringBuilder线程不安全，适用于单线程、 StringBuffer安全，因为方法里加了同步锁，适用于并发访问，
			

- **final、finally、finalize 的区别？**

	final用来修饰类、属性、方法，分别代表不可继承，不可变，不可重写。
	
	finally是异常处理结构的一部分，代表着总是执行
	
	finalize是Object类的方法，在垃圾回收时会调用被回收对象的finalize方法。
	
- 为什么重写equals方法就要重写hashCode方法？

	因为Object类的hashCode()方法有这么一个规定：两对象equals返回的结果为true，则他们的hashCode的值必须相等。否则将破坏使用到了相
	应的集合框架。
	
		例如：
		 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。
		 
		 又例如自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals。否则会时存储多个自定义相同的对象。