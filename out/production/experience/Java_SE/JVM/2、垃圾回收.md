#### 垃圾回收机制

- **GC回收机制?**

	一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制(太拗口，换句话说就是回收无用对象并释放它所占用的内存空间的机制)

- **判断一个对象是否死亡？**

	1. 引用计数器算法：
    
    		创建对象时添加一个引用计数器，每当有一个地方引用它时，引用计数器加一，当引用失效或者超过生命周期时，计数器值减一；
    		任何时刻对象的引用计数器为0的对象就是不可能再被使用的；
    		
    2. 可达性算法分析：
    
    		通过GC Roots进行可达性搜索，一个对象不在任何一条能到达GC Roots的引用链上，则视为不可达对象。
    		则证明此对象是不可用的，JVM稍后将会对此类对象进行回收

- **GCRoots的对象?**

	1. 虚拟机栈中中引用的对象；
    
    2. 本地方法栈中引用的对象
    
    3. 方法区静态属性引用的对象
    
    4. 方法区中常量引用的对象；

- **四引用?**

	1. 强引用（Strong Reference）

    		 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。
    		 
    2. 软引用（Soft Reference）
    
    		 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。
    		 
    3. 弱引用（Weak Reference）
    
         	 弱引用指向的对象发生GC时必定回收它的内存空间。
          
    4.  虚引用（Phantom Reference）
    
    		虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。

- **常见的垃圾收集算法？**

	1. 标记-清除算法：
	
			分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
	
		缺点：
		
			一是效率问题，标记和清除效率都不高，
			二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序在运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
			
	2. 复制算法
	
			可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活这的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
			
		优缺点：
			
			内存分配时不用考虑内存碎片等复杂情况，实现简单运行高效。
			
			但是代价是将内存缩小为了原来的一半。需要使用额外的空间进行分配担保防止全部存活的情况
			且对象存活率较高时就要进行较多的复制操作，效率将会变低
			
	3. 标记-整理算法
	
			标记过程仍与“标记-清除”算法一样，但是后续步骤是让所有的存活对象都向一端移动，然后直接清理掉端边界以外的内存
			
	4. 分代收集算法
	
			根据对象存活周期的不同。一般将内存划分为新生代和老年代，在新生代中采用复制算法,老年代使用“标记-清理”或者“标记-整理”算法。
			

- **Minor GC & Major GC & Full GC?**

	Minor GC：
	
		定义：指新生代GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作。
		
		触发条件：当新生代无法为新生对象分配内存空间的时候，会触发Minor GC
		
	Major GC：
	
		定义：Major GC清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。
	
	Full GC：
	
		定义：Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。
		
		注意：Full GC不等于Major GC，也不等于Minor GC+Major GC，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收。
           
          
- **GC垃圾收集器种类？**

	- 新生代收集器：
	
		1. Serial收集器:
		
				算法：采用复制算法的新生代收集器
				
				线程：单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作
		
				STW：进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）
				
				适用场景：HotSpot虚拟机运行在Client模式下的默认的新生代收集器
				
				优点：简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销
			
		2. ParNew 收集器：Serial收集器的多线程版本
		
				算法：同Serial收集器
				
				线程:并行多线程收集器，可使用多个CPU或者多条收集线程完成垃圾收集工作
				
				STW：同Serial收集器
				
				适用场景：运行Server模式下的虚拟机中首选的新生代收集器
				
				优点：多CPU环境下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的
				
				缺点：单CPU的环境中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，
				     该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越
				
				注：并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
                   并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。   
		3. Parallel Scavenge 收集器:并行的多线程新生代收集器
		
				算法：复制算法
				
				线程：并行多线程
				
				STW：进行垃圾收集时，必须暂停其他所有的工作线程，直至Parallel Scavenge收集器收集结束为止
				
				使用场景：适合在后台运算而不需要太多交互的任务
				
				优点：可达到一个可控制的吞吐量（Throughput）。
				     同时提供了GC自适应的调节策略（GC Ergonomics）。虚拟机会根据系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量
				
				注： 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。
				
				    停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。
				    从而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务
		
	- 老年代收集器：
			
		1. Serial Old收集器：Serial收集器的老年代版本
		
				算法：“标记-整理”算法
				
				线程：同Serial收集器
				
				STW：同Serial收集器
				
				适用场景：同Serial收集器
				
				优点：同Serial收集器
				
		2. Parallel Old收集器：Parallel Scavenge收集器的老年代版本
		
				算法：“标记-整理”算法
				
				线程：并行多线程
				
				STW：同Parallel Scavenge收集器
				
				适用场景：同Parallel Scavenge收集器
				
				优点：同Parallel Scavenge收集器
				
		3. CMS收集器
		
		4. G1收集器
- **G1相关？与CMS的区别？**

- **内存分配与回收策略?**



